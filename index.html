<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <link rel="icon" type="image/svg+xml" href="/favicon.ico"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>조대찬의 포트폴리오</title>
  <meta name="author" content="조대찬"/>
  <meta
    name="description"
    content="조대찬의 포트폴리오"
  />
  <meta property="og:title" content="조대찬의 포트폴리오"/>
  <meta
    property="og:description"
    content="조대찬입니다"
  />
  <meta property="og:image" content="https://daechan-jo.github.io/-__-/favicon.ico"/>
  <meta property="og:url" content="https://daechan-jo.github.io/-__-/"/>
  <meta property="og:type" content="website"/>
  <title>포트폴리오</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      line-height: 1.8;
      scroll-behavior: smooth;
    }

    :root {
      --bg-color: #ffffff;
      --text-color: #333333;
      --link-color: #333333;
      --link-hover-bg: #333333;
      --link-hover-color: #ffffff;
      --border-color: #333333;
      --highlight-color: #5971ae
    }

    body.dark-mode {
      --bg-color: #333333;
      --text-color: #ffffff;
      --link-color: #ffffff;
      --link-hover-bg: #ffffff;
      --link-hover-color: #333333;
      --border-color: #ffffff;
      --highlight-color: #5971ae
    }

    header {
      text-align: center;
      padding: 40px 20px;
      background-color: var(--bg-color);
    }

    header img {
      max-width: 150px;
      margin-bottom: 20px;
    }

    header h1 {
      font-size: 2em;
      margin: 0;
    }

    header p {
      font-size: 1em;
      color: var(--text-color);
    }

    .content {
      max-width: 900px;
      margin: 0 auto 50px;
      padding: 20px 20px 50px;
    }

    .content h2 {
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 10px;
      margin-bottom: 20px;
    }

    .content h3 {
      padding-bottom: 4px;
      margin-bottom: 20px;
      display: inline-block;
      position: relative;
    }

    .content h3::after {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0.15em;
      height: 0.15em;
      background-color: var(--highlight-color);
      z-index: -1;
    }

    .content p {
      text-align: left;
      font-size: 1em;
      color: var(--text-color);
    }

    .content section {
      margin-top: 40px;
    }

    .sidebar {
      position: fixed;
      top: 100px;
      left: 10px;
      width: 160px;
      padding: 10px 10px;
      border-right: 3px solid var(--border-color);
      max-height: 75vh;
      overflow-y: auto;
    }

    .sidebar ul {
      list-style-type: none;
      padding: 0;
      font-size: 0.9em;
    }

    .sidebar ul li {
      margin-bottom: 10px;
    }

    .sidebar ul li a {
      color: var(--link-color);
      text-decoration: none;
      display: block;
      transition: background-color 0.3s, color 0.3s;
    }

    .sidebar ul li a.main-category {
      font-weight: bold;
      font-size: 1em;
    }

    .sidebar ul li ul li a {
      font-size: 0.9em;
      padding-left: 10px;
    }

    .sidebar ul li a.active, .sidebar ul li a:hover {
      background-color: var(--link-hover-bg);
      color: var(--link-hover-color);
    }

    .toggle-btn {
      position: fixed;
      top: 10px;
      right: 10px;
      background-color: var(--border-color);
      color: var(--bg-color);
      border: 1px solid var(--border-color);
      padding: 7px 20px;
      cursor: pointer;
      transition: background-color 0.3s, color 0.3s;
    }

    .toggle-btn:hover {
      background-color: var(--bg-color);
      color: var(--border-color);
    }

    footer {
      text-align: center;
      padding: 20px;
      margin-top: 100px;
      background: var(--border-color);
      color: var(--link-hover-color);
    }

    @media (max-width: 1500px) {
      .content {
        padding-left: 220px;
        padding-right: 220px;
        margin-left: 50px;
        margin-right: 50px;
      }
    }

    @media (max-width: 1200px) {
      .sidebar {
        position: relative;
        top: 0;
        left: 0;
        width: 100%;
        border-left: none;
        border-top: 3px solid var(--border-color);
        margin-bottom: 20px;
        max-height: none;
        overflow-y: visible;
      }

      .sidebar ul {
        display: flex;
        flex-wrap: wrap;
      }

      .sidebar ul li {
        flex: 1 0 50%;
      }

      .sidebar ul li a {
        text-align: center;
      }

      .content {
        padding-left: 110px;
        padding-right: 110px;
      }
    }

    .tech-stack {
      margin-top: 20px;
    }

    .tech-stack h4 {
      font-size: 1.2em;
      margin-bottom: 10px;
    }

    .tech-stack p {
      font-size: 1em;
      color: var(--text-color);
      margin-bottom: 20px;
    }

    .cicd-container {
      display: flex;
      align-items: flex-start;
      margin-bottom: 20px;
    }

    .cicd-container img {
      max-width: 50%;
      height: auto;
      margin-right: 20px;
    }

    .cicd-container p {
      flex: 1;
    }

    .cicd-container ul {
      flex: 1;
    }

    .log-container img {
      max-width: 100%;
      height: auto;
      margin-right: 20px;
    }

    .tech-aws img {
      max-width: 100%;
      height: auto;
      margin-right: 20px;
    }

    .repository-pattern img {
      max-width: 100%;
      height: auto;
      margin-right: 20px;
    }

    .ioc, .repository-pattern {
      width: 100%;
    }

    .ioc img, .repository-pattern img {
      width: 100%;
      height: auto;
    }

    .rolling_bluegreen img {
      width: 100%;
      height: auto;
    }

    .cicd-list {
      counter-reset: item;
      list-style: none;
      padding-left: 0;
    }

    .cicd-list li {
      counter-increment: item;
      margin-bottom: 10px;
      position: relative;
      padding-left: 30px; /* 숫자가 위치할 공간 확보 */
    }

    .cicd-list li::before {
      content: counter(item) ". ";
      position: absolute;
      left: 0;
      font-weight: bold;
    }

    .recommend {
      position: relative;
      display: inline-block;
    }

    .recommend img {
      width: 100%;
      height: auto;
    }

    .caption {
      position: absolute;
      bottom: 5px;
      right: 10px;
      background-color: rgba(0, 0, 0, 0.5);
      color: white;
      font-size: 12px;
      padding: 2px 5px;
      border-radius: 3px;
      opacity: 0.7;
    }

    .score img {
      width: 100%;
      height: auto;
    }

    .trgmgin img {
      width: 100%;
      height: auto;
    }

    .cache img {
      width: 100%;
      height: auto;
    }

  </style>
</head>
<body>
<header>
  <img alt="Logo" src="splash.gif">
  <h1>LinkedOut</h1>
  <p>꾸밈 없는 나를 쓰다</p>
  <button class="toggle-btn" onclick="toggleMode()">다크모드</button>
</header>
<div class="content">
  <section id="projects">
    <section id="overview">
      <h2>프로젝트 개요</h2>
      <section id="project-name">
        <h3>프로젝트 이름 및 소개</h3>
        <p>LinkedOut은 개인의 성장과 자기 이해를 돕는 에세이 작성 플랫폼입니다. 이 플랫폼은 사용자가 자신의 감정을 온전히 마주할 수 있도록 도와주는 글쓰기 가이드라인과 환경을 제공합니다.
          LinkedOut을 통해 누구나 자유롭고 쉽게 본인만의 에세이를 작성할 수 있습니다. 글쓰기를 통해 감정을 해소하고자 하는 사람들을 위해 설계된 이 서비스는, 단순히 글을 쓰는 것만이 아니라
          솔직하고 깊은 감정을 글로 표현하는 것을 목표로 합니다.</p>
        <p>현대인들은 살아가면서 수많은 감정을 느끼지만, 타인의 시선 때문에 자신의 감정을 정확하게 표현하는 데 어려움을 겪습니다. 현재 시중에 나와 있는 많은 '글쓰기' 앱들은 SNS적인 요소가 강해,
          진솔한 글보다는 타인에게 잘 보이기 위한 꾸며낸 글이 대부분입니다. LinkedOut은 이러한 문제를 해결하기 위해 다음과 같은 특징을 가지고 있습니다:</p>
        <ul>
          <li>개인적인 감정과 감상을 솔직하게 표현할 수 있도록 익명성을 보장합니다.</li>
          <li>사용자 글에 좋아요, 조회수, 스크랩 수 등을 표시하지 않아, 내면의 이야기를 막힘없이 쓸 수 있도록 합니다.</li>
        </ul>
      </section>
      <section id="goal">
        <h3>목표</h3>
        <p>LinkedOut의 주요 목표는 사용자가 자신의 이야기를 솔직하고 자유롭게 공유할 수 있는 공간을 제공하는 것입니다. 이를 통해 다음과 같은 목표를 달성하고자 했습니다.</p>
        <ul>
          <li>사용자들이 자신의 감정을 솔직하게 표현하고, 이를 통해 감정을 해소할 수 있도록 지원합니다.</li>
          <li>진정한 자기 이해와 성장을 돕는 글쓰기 환경을 제공합니다.</li>
          <li>타인의 시선에서 벗어나 자신의 이야기를 자유롭게 쓸 수 있는 공간을 마련합니다.</li>
          <li>익명성을 통해 사용자들이 더 솔직하게 자신의 이야기를 풀어낼 수 있도록 합니다.</li>
          <li>SNS적인 요소를 배제하여 사용자들이 진정성 있는 글을 작성할 수 있게 합니다.</li>
        </ul>
      </section>
      <section id="tech-stack">
        <h3>기술스택</h3>
        <div class="tech-stack">
          <h4>NestJS</h4>
          <p>NestJS는 Node.js의 유연함이 오히려 단점이 되는 상황을 극복하기 위해 선택했습니다. 자연스럽게 규칙들을 지키게 하며, TypeScript 사용으로 정적 타입 검사를 통한 오류 방지가
            가능합니다. 모듈화된 구조로 코드의 유지보수와 확장이 용이하며, 기본적인 패턴을 제시하여 개발을 편리하게 합니다. 주로 사용하던 Express보다 더 프레임워크에 가깝기 때문에 구조화된 개발을
            할 수 있습니다. 또한, 의존성 주입(Dependency Injection)을 제공하여 코드의 모듈성과 재사용성을 높이는 데 큰 도움이 되었습니다.</p>

          <h4>TypeORM</h4>
          <p>엔티티를 객체로 관리하여 좀 더 객체지향적인 접근을 가능하게 합니다. 데이터베이스 엔티티와 클래스 간의 매핑을 통해 객체 지향적 데이터베이스 접근이 가능하며, TypeScript와의 호환성이
            좋고, 코드베이스를 일관성 있게 유지하는 데 유리했습니다. 데이터베이스 스키마를 코드로 정의하고, 특히 마이그레이션을 쉽게 관리할 수 있었습니다.</p>


          <h4>PostgreSQL</h4>
          <p>모든 구성에서 ACID 규정을 준수하며, 이는 트랜잭션의 원자성, 일관성, 고립성, 지속성을 보장해 데이터의 무결성을 유지하기 유리합니다. 또한 동시성 제어를 통해 여러 트랜잭션이 동시에
            실행될 때도 데이터 일관성을 유지하며 다양한 인덱스 방식을 지원해 효율적이고 빠른 데이터 검색을 가능합니다.</p>

          <h4>AWS</h4>
          <p>다양한 클라우드 서비스와 복잡한 인프라 설정을 간편하게 관리할 수 있었습니다. 이번 프로젝트에서는 ECS, ECR, RDS, ElastiCache, S3, CodePipeline,
            CloudFront, CloudWatch, Route 53 등의 서비스를 사용했습니다.</p>
        </div>
      </section>
    </section>
    <br/>
    <br>
    <br>
    <section id="architecture">
      <h2>아키텍처 및 설계</h2>
      <section id="architecture-aws">
        <h3>AWS 인프라 아키텍처</h3>
        <div class="tech-aws">
          <img alt="아마존 아케틱쳐" src="aws_architecture.png" onclick="window.open(this.src)">
        </div>
        <p>AWS 인프라는 두 개의 가용 영역을 사용해 구축했습니다. 다음은 주요 특징입니다.</p>
        <ul>
          <li>
            <strong>서브넷 분리</strong>
            <p>
              유일한 입구인 인터넷 게이트웨이와 연결되어 있으며, 프라이빗 서브넷과의 연결 통로로만 사용했습니다.<br/>프라이빗 서비넷은 넷게이트웨이를 통해 외부와 연결하고, 내부 네트워크에서만 접근이
              가능하도록 해 외부로부터 격리되어 보안을 유지했습니다. 이를 통해 보안 그룹과 네트워크 ACL을 통해 보안을 더욱 강화할 수 있었습니다.
            </p>
          </li>
        </ul>
        <ul>
          <li>
            <strong>수평적 확장성 및 고가용성</strong>
            <p>
              로드밸런서와 ECS를 활용해 트래픽 변화에 유동적으로 대응할 수 있도록 구성했습니다.<br/>오토스케일링을 통해 트래픽의 증가나 감소에 따라 자동으로 인스턴스를 추가하거나 제거해 비용을
              최적화 할 수 있으며 이러한 구조를 통해 서비스의 가용성을 높이고 장애 발생 시 보다 신속하게 대응할 수 있습니다.
            </p>
          </li>
        </ul>
        <ul>
          <li>
            <strong>트래픽 필터링</strong>
            <p>
              CloudFront를 사용해 S3 퍼블릭 버킷의 보안을 강화하고 악의적인 트래픽을 필터링합니다.<br/>전 세계에 분포된 엣지 로케이션에서 콘텐츠를 캐싱해 사용자와 더 가까운 위치의 엣지에서
              콘텐츠를 제공함으로써 지연 시간을 줄이고 성능을 향상시킵니다.<br/>이 캐싱 기능 덕분에 동일한 콘텐츠에 대한 반복적인 요청을 엣지 로케이션에서 처리하여 S3버킷으로의 요청을 줄이기 때문에
              S3를 단독으로 사용할 때보다 더 빠른 응답 속도를 제공할 수 있었습니다.
            </p>
          </li>
        </ul>
      </section>
      <br>
      <section id="design-patterns">
        <h3>주요 설계 패턴</h3>
        <h4>리파지토리 패턴</h4>
        <div class="repository-pattern">
          <img src="repository.png" alt="리포지토리패턴" onclick="window.open(this.src)">
        </div>
        <p>서비스 로직에서 데이터 접근 로직을 다른 레이어로 분리해 추상화하여 결합도를 낮추고, 서비스 로직은 서비스에만 집중할 수 있도록 했습니다. 테스트코드를 보다 편리하게 작성할 수 있으며, 데이터
          접근 코드가 모듈화되어 유지보수성과 재사용성을 높일 수 있었습니다.</p>
        <br/>
        <h4>DI와 IoC, 그리고 싱글톤 패턴과 흐름</h4>
        <p>NestJS는 의존성 주입(DI)과 제어의 역전(IoC) 원칙을 바탕으로 설계되어 모듈화와 유지보수성을 향상시킬 수 있습니다.</p>
        <strong>- 의존성 주입 (Dependency Injection)</strong>
        <p>의존성 주입은 객체가 직접 다른 객체를 생성하지 않고 필요한 의존성을 외부에서 주입받는 디자인 패턴입니다. 이를 통해 클래스 간의 결합도를 낮추고, 코드의 유연성과 재사용성을 높일 수 있습니다.
          NestJS는 DI를 기본으로 채택하여 서비스, 컨트롤러, 리파지토리 등 다양한 컴포넌트 간의 의존성을 효율적으로 관리할 수 있습니다.</p>
        <ul>
          <li>
            생성자 주입: NestJS는 생성자 주입 방식을 사용해 의존성을 주입합니다. 클래스의 생성자에 필요한 의존성을 선언하면, NestJS의 IoC 컨테이너가 이를 자동으로 주입합니다.
          </li>
          <li>데코레이터 사용: `@Injectable()` 데코레이터를 사용해 클래스가 의존성을 주입받을 준비가 되었음을 표시합니다. 이 데코레이터는 클래스가 IoC 컨테이너에 의해 관리되도록
            합니다.
          </li>
        </ul>
        <br>
        <strong>- 제어의 역전 (Inversion of Control)</strong>
        <p>객체의 생성과 생명 주기를 개발자가 아닌 프레임워크나 컨테이너가 관리하는 디자인 원칙으로 NestJS는 IoC 컨테이너를 사용하여 애플리케이션의 객체를 생성하고 의존성을 주입하며, 객체의 생명
          주기를 관리합니다. 이를 통해 객체 생성 및 관리에 신경 쓰지 않고 비즈니스 로직에 집중할 수 있습니다.</p>
        <ul>
          <li>
            IoC 컨테이너: IoC 컨테이너는 애플리케이션이 시잘될 때 필요한 모든 의존성을 인스턴스화하고 주입합니다.
          </li>
          <li>
            모듈 시스템: `@Module()` 데코레이터를 사용하여 모듈을 정의합니다. 모듈은 NestJS 애플리케이션의 기본 구성 단위로, 특정 기능과 관련된 프로바이더(서비스, 리포지토리 등)를
            그룹화합니다. 이렇게 정의된 모듈은 IoC 컨테이너에 등록되어 의존성 주입을 통해 다른 모듈이나 컴포넌트에서 사용할 수 있습니다.
          </li>
        </ul>
        <br>
        <strong>- 싱글톤 패턴 (Singleton Pattern)</strong>
        <p>싱글톤 패턴은 특정 클래스의 인스턴스가 하나만 생성되고, 애플리케이션 전체에서 동일한 인스턴스를 공유하도록 하는 디자인 패턴입니다. NestJS는 기본적으로 프로바이더를 싱글톤으로 관리하기 때문에
          메모리를 효율적으로 관리하고 상태를 공유하는데 유용했습니다.</p>
        <ul>
          <li>
            싱글톤 프로바이더: @Injectable() 데코레이터를 사용하여 정의된 모든 프로바이더는 기본적으로 싱글톤으로 동작합니다. 따라서 동일한 프로바이더 인스턴스가 애플리케이션 전체에서
            재사용됩니다.
          </li>
          <li>
            상태 공유: 싱글톤 프로바이더는 애플리케이션 내에서 상태를 공유하는 데 유용합니다. 예를 들어 하나의 데이터베이스 연결을 여러 서비스에서 공유할 수 있습니다.
          </li>
        </ul>
        <br/>
        <strong>- 흐름 (예시: 로그인)</strong>
        <div class="ioc">
          <img alt="ioc" src="nestjs_ioc.png" onclick="window.open(this.src)">
        </div>
        <br>
        <strong>IoC 컨테이너 설정</strong>
        <ul>
          <li>애플리케이션이 시작되면 IoC 초기화 단계에서 모든 모듈의 의존성 설정이 IoC 컨테이너에 등록됩니다.</li>
          <li>최상위 모듈인 `AppModule`이 초기화되며, 여기서 데이터베이스 및 Redis와 같은 전역적으로 필요한 의존성들이 설정됩니다.</li>
          <li>`AuthModule`과 `UserModule`이 `AppModule`에 의해 임포트되어 의존성이 설정되고, 각 모듈 내의 컨트롤러와 서비스, 리포지토리 등이 `providers`로 등록되어
            IoC 컨테이너에 의해 싱글톤 인스턴스로 생성/관리 됩니다.
          </li>
          <li>로그인 위한 라우터가 `AuthModule`에 있고, 요청을 처리하기 위해 `UserModule`의 서비스 의존성이 필요하다고 가정할 때 `UserModule`을 `AuthModule`에
            임포트하여 의존성을 설정합니다.
          </li>
        </ul>
        <br>
        <strong>로그인 요청 처리</strong>
        <ul>
          <li>클라이언트의 로그인 요청이 `AuthController`로 들어옵니다.</li>
          <li>`AuthController`는 주입된 `AuthService`를 사용해 요청을 처리합니다.</li>
          <li>`AuthService`는 요청을 처리하는 과정에서 `UserService`를 주입받아 사용하며, `UserService`는 `UserRepository` 와 외부 API에 의존해 요청을
            처리하게 됩니다.
          </li>
        </ul>
      </section>
    </section>
    <br/>
    <br>
    <br>
    <section id="main-features">
      <h2>주요 기능</h2>
      <section id="recommend">
        <h3>랜덤 추천 에세이</h3>
        <div class="recommend">
          <img src="recommend.png" alt="추천에세이시퀀스" onclick="window.open(this.src)">
          <span class="caption">클릭하시면 원본 크기로 보실 수 있습니다.</span>
        </div>
        <br>
        <br>
        <p>랜덤 추천 에세이 조회 기능은 사용자가 랜덤으로 추천된 에세이 목록을 조회합니다.<br> 이 기능은 사용자가 최근에 조회한 글들의 태그 일치도, 북마크 수, 트렌드 점수, 작성자의 평판 등
          사용자의 최근 활동과 선호도 및 여러 가중치를 반영하여 보다 개인화된 추천을 제공합니다. 선택된 에세이의 내용 일부를 추출하여 미리보기를 제공하여 사용자가 에세이의 대략적인 내용을 파악할 수 있도록
          했습니다. 에세이 테이블이 매우 커질 경우, 가중치를 적용한 모든 에세이에서 요청한 에세이 수 만큼 랜덤 선택하는 것은 리소스 효율이 좋지 못했고 레이턴시 또한 길어졌습니다. 따라서 가중치를 적용한
          상위 1000개의 에세이를 먼저 조회한 후, 이 중에서 랜덤으로 요청된 수 만큼의 에세이를 선택하도록 해서 최적화했습니다.</p>
        <ul>
          <li>
            <strong>최근 활동 기반 태그 수집</strong>
            <p>사용자가 최근에 본 에세이들의 태그를 수집하여 최근 태그 목록을 만들어 사용자의 현재 관심사를 반영합니다. 예를 들어, 사용자가 최근에 본 에세이들에서 '자기계발', '여행' 등의 태그가
              있다면, 이 태그들이 최근 태그 목록에 포함됩니다.</p>
          </li>
          <li>
            <strong>가중치 기반 에세이 조회</strong>
            <p><strong>북마크:</strong> 에세이가 받은 북마크 수가 많을수록 높은 가중치를 받습니다.</p>
            <p><strong>태그:</strong> 사용자의 최근 태그와 일치하는 태그를 가진 에세이에 가중치를 부여합니다.</p>
            <p><strong>트렌드:</strong> 에세이의 트렌드 점수는 작성일, 조회수 기반으로 부여되며, 높은 트렌드 점수를 기반으로 가중치를 부여합니다.</p>
            <p><strong>작성자 평판:</strong> 에세이 작성자의 평판을 기준으로 가중치를 부여합니다.</p>
          </li>
          <li>
            <strong>에세이 필터링</strong>
            <p><strong>비공개 에세이:</strong> 사용자의 개인정보 보호를 위해 에세이의 상태가 비공개인 경우 조회되지 않도록 필터링합니다.</p>
            <p><strong>신고된 에세이:</strong> 사용자의 불쾌감을 줄이기 위해, 요청자가 이전에 신고한 에세이는 조회되지 않도록 필터링합니다.</p>
          </li>
        </ul>
      </section>
      <br>
      <section id="score">
        <h3>사용자 평판 및 에세이 트렌드 점수 관리</h3>
        <div class="score">
          <img src="score.png" alt="평판트렌드" onclick="window.open(this.src)">
          <p>사용자 활동과 에세이의 트렌드 점수를 효율적으로 관리해, 플랫폼의 신뢰성과 사용자 경험을 극대화하고자 했습니다. 평판과 트렌드 점수는 이 서비스의 핵심기능이라 할 수 있는 추천 에세이 조회
            쿼리에 사용되었습니다.</p>
          <ul>
            <li>
              <strong>사용자 평판 관리</strong>
              <p><strong>에세이 조회 시 평판 증가: </strong>특정 조휘수에 도달할 때마다 작성자의 평판을 증가시켰습니다. 예를 들어 에세이 조회수가 100의 배수가 될 때마다 평판이 1점
                증가합니다.</p>
              <p><strong>에세이 작성 시 평판 증가: </strong>사용자가 주기적으로 에세이를 작성할 때 평판이 증가하도록 했습니다. 최근 일주일 내에 2편 이상 작성하거나, 최근 한 달 내에
                8편 이상 작성한 경우 평판이 각각 5점씩 증가합니다.</p>
              <p><strong>북마크 추가 시 평판 증가: </strong>사용자가 에세이를 북마크하면 해당 에세이 작성자의 평판이 증가하고, 에세이의 트렌드 점수도 증가합니다.</p>
            </li>
            <br>
            <li>
              <strong>에세이 트렌드 점수 관리</strong>
              <p>트렌드 점수 계산 로직은 에세이의 인기도를 반영하기 위해 조회 시 점수를 증가시키고, 작성된 날짜에 따라 점수가 감소하도록 설계했습니다. 이를 통해 에세이의 최신성과 인기도를 균형있게
                유지할 수 있습니다.</p>
              <p>조회시 증가: 1</p>
              <p>감쇠 계수: 0.995</p>
              <p>작성 후 7일 동안은 감쇠를 적용하지 않고, 조회 시 점수만 증가합니다.</p>
              <p>트렌드 점수는 최소 0 이상으로 유지됩니다.</p>
              <br>
              <strong>작성 7일 이내</strong>
              <ul>
                <li>
                  트렌드 점수는 감소하지 않으며, 조회 시마다 1씩 증가합니다.
                </li>
                <li>예: 100 -> 101 -> 102 ...</li>
              </ul>
              <strong>작성 후 10일째 조회</strong>
              <ul>
                <li>
                  7일동안은 감쇠를 적용하지 않기에, 그 이후로 3일이 감쇠 계수에 적용되어 일별 0.5% 씩 감소합니다.
                </li>
                <li>
                  그래서 7일 이후의 3일 동안의 감소율은 `100 * 0.995^3 ≈ 98.5` 가 됩니다.
                </li>
                <li>
                  만약 에세이의 트렌드 점수가 100이였다고 가정했을 때, 새로운 트렌드 점수는 `98.5` + `1`(조회증가량) = `99.5` -> `99`(소수점 버림) 이 됩니다.
                </li>
              </ul>
              <br>
              <strong>트렌드 점수 관리를 조회 트리거로 하는 이유</strong>
              <p>트렌드 점수 관리는 사용자가 에세이를 조회할 대마다 트리거됩니다. 크론 작업을 통한 주기적 업데이트와 비교했을 때 다음과 같은 이점이 있었습니다.</p>
              <ul>
                <li>
                  <strong>효율적인 리소스 사용: </strong>크론 작업은 정해진 시간 간격마다 모든 에세이의 트렌드 점수를 업데이트해야 하므로 서버 리소르를 많이 소모해야 했습니다. 반대로
                  조회 트리거 방식은 사용자가 실제로 에세이를 조회할 때만 점수를 업데이트하므로 리소스를 보다 효율적으로 사용합니다.
                </li>
                <li>
                  <strong>실시간 반영: </strong>사용자의 활동에 따라 실시간으로 트렌드 점수가 반영되어 더 정확한 인기도 평가가 가능합니다. 이는 사용자 경험을 향상시키고 최신 정보를
                  제공하는데 유리합니다.
                </li>
              </ul>
            </li>
          </ul>
        </div>
      </section>
      <br>
      <section id="search">
        <h3>에세이 검색 기능</h3>
        <div class="trgmgin">
          <img src="trgmgin.png" alt="trgmgin.png" onclick="window.open(this.src)">
        </div>
        <p>에세이 검색 기능은 사용자가 입력한 키워드를 기반으로 유사도 높은 에세이를 효율적으로 검색할 수 있도록 설계했습니다. 이를 위해 PostgreSQL의 trgm(Trigram)과
          GIN(Generalized Inverted Index)인덱스를 활용해서 대용량 데이터에서도 빠르고 정확한 검색 결과를 제공할 수 있습니다.</p>
        <br>
        <p>
          <strong>
            trgm과 GIN 인덱스, 그리고 Full Text Search
          </strong>
        </p>
        <ul>
          <li>
            <strong>trgm(Trigram): </strong>문자열에서 3개의 연속된 문자(트라이그램)을 이용하여 문자열 간의 유사도를 측정합니다. 예를 들어 '안녕하세요' 라는 문자열은
            ['안녕', '녕하', '하세', '세요']와 같은 트라이그램을 가지게 되고 이를 통해 문자열 유사도를 빠르게 계산할 수 있습니다. 예를 들어, '고양이'와 '고양이들'은 '고양이'라는
            트라이그램을 공유하므로 유사도가 높게 평가됩니다.
          </li>
          <br>
          <li>
            <strong>GIN(Generalized Inverted Index): </strong> PostgreSQL의 인덱스 타입 중 하나로 매우 효율적인 검색 성능을 제공합니다. 특히 trgm과
            함께 사용하면 높은 성능을 발휘합니다. 예를 들어 '고양이'라는 키워드를 검색하면, gin 인덱스는 트라이그램 '고양'을 포함하는 모든 문자열을 빠르게 찾아낼 수 있습니다.
          </li>
          <br>
          <li>
            <strong>uaaccent 확장: </strong>PostgreSQL의 확장 중 하나로 텍스트에서 악센트나 다이아크리틱 문자를 제거해서 표준화된 형태로 변환해줍니다. 한글에는 악센트가 없지만
            영어 등 다국어 텍스트를 포함할 수 있는 경우 유용하게 사용할 수 있습니다.
          </li>
          <br>
          <li>
            <strong>
              전체 텍스트 검색(Full Text Search):
            </strong>
            PostgreSQL의 tsvector 타입을 사용해 텍스트를 토큰화하고 인덱싱합니다. 텍스트의 각 단어를 분리하고, 각 단어의 위치와 중요도를 저장합니다. 예를 들어 "안녕하세요. 저는
            개발자입니다."는 다음과 같은 tsvector로 변환됩니다.
            <br>
            <code>'안녕하세요':1A '저는':2B '개발자':3C '입니다':4D</code>
            <br>
            전체 텍스트 검색에서는 tsquery를 사용해 검색어를 토큰화하고 미리 생성해둔 vector 필드와 비교해 일치하는 결과를 찾습니다.
          </li>
        </ul>
        <br>
        <strong>키워드 분석 및 쿼리 빌드</strong>
        <ul>
          <li>
            <strong>키워드 길이가 3자 미만인 경우: </strong>키워드가 짧은 경우 트라이그램이 충분히 생성되지 않아 유사도 분석이 부정확할 수 있기 때문에 tsvector 타입으로 생성해둔
            필드를 사용해 검색 정확도를 높입니다. 예를 들어 '안녕'이라는 키워드는 '안녕'이라는 단일 트라이그램만 생성하므로 유사도 분석이 부정확할 수 있습니다. 따라서 전체 텍스트 검색을 사용하면 더
            정확한 결과를 얻을 수 있습니다.
          </li>
          <li>
            <strong>키워드 길이가 3자 이상인 경우: </strong>3자 이상의 키워드는 충분한 트라이그램이 생성되어, trgm을 사용해 유사도 검색을 수행하면 보다 정밀한 유사도 분석이
            가능합니다. 이때 GIN 인덱스를 사용해서 일치하는 트라이그램 텍스트를 빠르게 찾을 수 있습니다.
          </li>
        </ul>
        <br>
      </section>
    </section>
    <br/>
    <section id="performance">
      <h2>성능 최적화 및 확장성</h2>
      <section id="caching-strategy">
        <h3>캐싱 전략</h3>
        <div class="cache">
          <img src="cache.png" alt="캐싱" onclick="window.open(this.src)">
        </div>
        <p>데이터 일관성의 중요도에 따라 적절한 캐싱 전략을 사용해 성능을 최적화하고 일관성을 유지했습니다.</p>
        <br>
        <ul>
          <li>
            <strong>사용자 데이터 캐싱</strong>
            <p><strong>Write-Through 전략:</strong> 유저데이터는 애플리케이션 전역에서 빈번하게 사용하고, 사용자 인가에서 사용하는 정보이기 때문에 데이터 일관성을 유지하는 것이
              필수적이였습니다.<br>예시로 현재
              적용한
              인가 시스템은 매 요청마다 요청자를 인증하고 JWT를 갱신하는 방식이기 때문에 사용자 정보가 업데이트 된 경우 페이로드도 같이 변경될 수 있기 때문에 일관성을 유지해야하기 때문에
              Write-Through 전략을 사용해서 데이터베이스에 쓰기 작업을 수행할 때 캐시도 동시에 업데이트하여 일관성을 유지했습니다.</p>
          </li>
          <br>
          <li>
            <strong>에세이 검색 결과 캐싱</strong>
            <p><strong>Cache-aside 전략: </strong>에세이 검색 결과는 자주 갱신되지 않으며, 데이터의 일관성이 다소 덜어져도 큰 문제가 되지 않기 때문에 Cache-aside
              전략을 사용하여 캐시에 데이터가 없을 때만 데이터베이스에서 데이터를 조회하고 캐시에 저장합니다. 이와 함께 TTL이 지나면 자동으로 무효화되어서 최소한의 일관성을 보장할 수 있습니다.
              최소한의 일관성을 보장했습니다.
            </p>
          </li>
        </ul>
      </section>
      <section id="queue-system">
        <h3>큐 시스템을 이용한 작업 분산</h3>
        <p>큐 시스템 내용</p>
      </section>
    </section>
    <br/>
    <section id="security">
      <h2>보안</h2>
      <section id="data-protection">
        <h3>데이터 보호</h3>
        <p>데이터 보호 내용</p>
      </section>
      <section id="input-validation">
        <h3>입력 검증</h3>
        <p>입력 검증 내용</p>
      </section>
      <section id="session-management">
        <h3>로그인 및 세션 관리</h3>
        <p>로그인 및 세션 관리 내용</p>
      </section>
    </section>
    <br/>
    <section id="devops">
      <h2>DevOps 및 배포</h2>
      <section id="cicd">
        <h3>CI/CD 파이프라인</h3>
        <br/>
        <p class="cicd-description">해당 CI/CD 파이프라인은 프로젝트 기간 동안 불필요한 시간 소모를 줄이기 위해 가장 먼저 구축되었습니다. 비록 혼자서 서버를 개발했지만, PR과
          코드 리뷰 과정 자체가 익숙하지 않아서 추후 협업에 있어 빠르게 적응할 수 있도록 하기 위함도 있었습니다. 이 과정을 통해 잘못된 푸쉬를 미연에
          방지하고, 코드 리뷰 및 협업 프로세스에 익숙해질 수 있도록 하였습니다. 과정은 다음과 같습니다.</p>
        <div class="cicd-container">
          <img alt="CI/CD 파이프라인 다이어그램" src="cicd.png" onclick="window.open(this.src)">
          <ul class="cicd-list">
            <br>
            <li>새로운 기능이나 버그 수정을 완료한 후 메인 브랜치에 PR을 생성합니다.</li>
            <br>
            <li>깃허브 액션에서 테스트 코드가 실행됩니다.</li>
            <br>
            <li>테스트 성공 및 리뷰가 끝나면 머지합니다.</li>
            <br>
            <li>깃허브 액션에서 메인 브랜치의 변경을 감지하고 도커 이미지를 생성하여 ECR로 푸쉬합니다.</li>
            <br>
            <li>ECR에 새로운 이미지가 생성되면 AWS 파이프라인의 소스 단계에서 이를 감지합니다.</li>
            <br>
            <li>빌드 단계에선 소스 단계에서 가져온 이미지를 이전 ECS 테스크 정의 파일을 가져와 새로운 이미지로 테스크를 재정의 합니다.</li>
            <br>
            <li>배포 단계에선 설정한 ECS 서비스에 새로운 테스크정의를 전달합니다.</li>
            <br>
            <li>롤링 업데이트가 실행되고 배포가 완료됩니다.</li>
          </ul>
        </div>
        <br/>
        <p>CI/CD 파이프라인 구축의 중요한 요소 중 하나는 무중단 배포를 구현하는 것 이였습니다. ECS를 사용중이였기에 선택지는 두 가지였습니다.</p>
        <div class="rolling_bluegreen">
          <img alt="배포방법비교" src="rolling_bluegreen.png" onclick="window.open(this.src)">
        </div>
        <p>두 방법 모두 무중단 배포를 지원하지만 배포 방식에는 뚜렷한 차이가 있어 고려해야 될 부분이 있었습니다.<br/></p>
        <ul>
          <li>
            롤링업데이트: 새 버전을 점진적으로 배포하여 기존 버전을 새로운 버전으로 교체하는 방법.
          </li>
          <li>
            블루/그린: 두 개의 동일한 환경을 사용하는 배포 방법.
          </li>
        </ul>
        <p>롤링업데이트 순차적으로 인스턴스를 업테이트하기 때문에 리소스 측면에서 효율적이지만, 업데이트 중 상태 공유 문제나 데이터 일관성 문제가 발생할 수 있다는 단점이 있었습니다. <br/>반대로
          블루/그린 배포는 별도의 두 개의 환경을 사용해 배포하면서 트래픽을 한번에 새 버전으로 전환하기 때문에 롤링업데이트의 단점을 보완할 수 있지만 리소스 사용이 증가함에 따라 인프라비용이 증가한다는
          단점이 있었습니다.<br/><br/>최우선 목표로 비용절감 우선순위가 높았기에 롤링업데이트 방식을 선택하게 되었지만, 추후에 이용자가 증가하고 큰 변경점이 발생하는 업데이트가 있을 시
          블루/그린으로의 전환을 고려해야할 것 같습니다.</p>
      </section>
      <section id="monitoring">
        <h3>모니터링 및 로깅</h3>
        <div class="log-container">
          <img alt="클라우드워치" src="cloudwatch.png" onclick="window.open(this.src)">
          <p>AWS의 가장 큰 장점이라 생각하는 CloudWatch 서비스를 적극 활용해 애플리케이션과 인프라를 모니터링하고 분석했습니다. 특히 사용중인 ECS와 연계하여 오토스케일링 및 각종 서비스의
            로그와 메트릭을 수집했습니다.<br/><br/>ECS는 현재 실행 중인 컨테이너의 지표가 설정한 기준을 일정 시간 이상 초과할 경우 추가적으로 컨테이너를 실행하여 트래픽 부하를 분산시키도록
            설정했습니다. 이를 위해 브릿지 네트워크 모드를 사용해 컨테이너 포트를 동적으로 할당했고 이때 CloudWatch는 다음과 같은 중요한 역할을 했습니다.<br/></p>
          <ul>
            <li>
              <strong>지표 수집 및 모니터링: </strong>ECS에서 실행 중인 각 컨테이너의 성능 지표를 실시간으로 수집해, 이를 통해 CPU 사용률, 메모리 사용률, 네트워크 트래픽 등의
              주요 메트릭을 모니터링하고 특정 기준을 초과할 경우 알림을 받을 수 있도록 설정했습니다.
            </li>
            <li>
              <strong>오토 스케일링: </strong> ECS 서비스는 CloudWatch 경보를 기반으로 오토 스케일링을 구성할 수 있었습니다. 예를 들어 CPU 사용률이 80%를 초과하는 경우
              추가 컨테이너를 자동으로 실행하여 부하를 분산시킬 수 있습니다. 이렇게 동적으로 컨테이너 수를 조정함으로써 트래픽 증가에 유연하게 대응할 수 있으며 결과적으로 필요할 때만 컨테이너를 추가
              실행하거나 종료함으로써 효율적인 리소스 사용이 가능해지며 비용절감을 기대할 수 있습니다.
            </li>
            <li>
              <strong>문제 감지 및 대응: </strong> 대시보드와 알람을 통해 시스템의 상태를 실시간으로 모니터링하고 문제가 발생할 경우 신속하게 대응해 시스템의 안정성과 가용성을 높이는데
              중요한 역할을 합니다.
            </li>
          </ul>
          <br/>
          <p>ECS를 제외하고도 사용중인 서비스들의 로그 그룹과 스트림을 통해 손쉽게 관리하고, 검색 및 필터링 기능을 활용하여 필요한 정보를 빠르게 찾을 수 있었으며 성능 메트릭을 실시간으로 모니터링해
            CPU, 메모리, 디스크 I/O, 네트워크 트래픽 등의 상태를 파악해 필요한 자원을 추가하거나 조정해 성능 문제를 예방할 수 있습니다. 또한 중요한 메트릭에 대해 알람을 설정해 문제가 발생했을
            때 즉시 대응할 수 있도록 설정하여 시스템의 안정성을 유지할 수 있도록 했습니다.</p>
        </div>
      </section>
    </section>
    <br/>
    <section id="api-docs">
      <h2>API 문서화</h2>
      <section id="swagger">
        <h3>스웨거 사용</h3>
        <p>스웨거 사용 내용</p>
      </section>
    </section>
    <br/>
    <section id="code-examples">
      <h2>코드 예시</h2>
      <section id="important-code">
        <h3>중요 로직 코드</h3>
        <p>중요 로직 코드 내용</p>
      </section>
    </section>
    <br/>
    <section id="results">
      <h2>성과 및 개선점</h2>
      <section id="project-results">
        <h3>프로젝트 성과</h3>
        <p>프로젝트 성과 내용</p>
      </section>
      <section id="improvements">
        <h3>향후 개선점</h3>
        <p>엘라스티서치사용, 캐싱전략, 블루그린</p>
      </section>
    </section>
    <br/>
    <br/>
  </section>
</div>
<div class="sidebar">
  <ul>
    <li><a class="main-category" href="#overview">프로젝트 개요</a></li>
    <ul>
      <li><a href="#project-name">- 프로젝트 이름 및 소개</a></li>
      <li><a href="#goal">- 목표</a></li>
      <li><a href="#tech-stack">- 기술스택</a></li>
    </ul>
    <br/>
    <li><a class="main-category" href="#architecture">아키텍처 및 설계</a></li>
    <ul>
      <li><a href="#architecture-aws">- AWS 인프라 아키텍처</a></li>
      <li><a href="#design-patterns">- 주요 설계 패턴</a></li>
    </ul>
    <br/>
    <li><a class="main-category" href="#main-features">주요 기능</a></li>
    <ul>
      <li><a href="#recommend">- 랜덤 추천 에세이</a></li>
      <li><a href="#score">- 평판 및 트렌드</a></li>
      <li><a href="#search">- 에세이 검색 기능</a></li>
    </ul>
    <br/>
    <li><a class="main-category" href="#performance">성능 최적화 및 확장성</a></li>
    <ul>
      <li><a href="#caching-strategy">- 캐싱 전략</a></li>
      <li><a href="#queue-system">- 큐 시스템을 이용한 작업 분산</a></li>
    </ul>
    <br/>
    <li><a class="main-category" href="#security">보안</a></li>
    <ul>
      <li><a href="#data-protection">- 데이터 보호</a></li>
      <li><a href="#input-validation">- 입력 검증</a></li>
      <li><a href="#session-management">- 로그인 및 세션 관리</a></li>
    </ul>
    <br/>
    <li><a class="main-category" href="#devops">DevOps 및 배포</a></li>
    <ul>
      <li><a href="#cicd">- CI/CD 파이프라인</a></li>
      <li><a href="#monitoring">- 모니터링 및 로깅</a></li>
    </ul>
    <br/>
    <li><a class="main-category" href="#api-docs">API 문서화</a></li>
    <ul>
      <li><a href="#swagger">- 스웨거 사용</a></li>
    </ul>
    <br/>
    <li><a class="main-category" href="#code-examples">코드 예시</a></li>
    <ul>
      <li><a href="#important-code">- 중요 로직 코드</a></li>
    </ul>
    <br/>
    <li><a class="main-category" href="#results">성과 및 개선점</a></li>
    <ul>
      <li><a href="#project-results">- 프로젝트 성과</a></li>
      <li><a href="#improvements">- 향후 개선점</a></li>
    </ul>
  </ul>
</div>
<footer>
  &copy; 2024 daechanJo All rights reserved.
</footer>

<script>
  function toggleMode() {
    document.body.classList.toggle('dark-mode');
    const btn = document.querySelector('.toggle-btn');
    if (document.body.classList.contains('dark-mode')) {
      btn.textContent = '라이트모드';
    } else {
      btn.textContent = '다크모드';
    }
  }

  document.querySelectorAll('.sidebar ul li a').forEach(anchor => {
    anchor.addEventListener('click', function (e) {
      document.querySelectorAll('.sidebar ul li a').forEach(link => link.classList.remove('active'));

      this.classList.add('active');

      e.preventDefault();
      const targetId = this.getAttribute('href').substring(1);
      const targetElement = document.getElementById(targetId);

      targetElement.scrollIntoView({
        behavior: 'smooth',
      });

      setTimeout(() => {
        this.classList.remove('active');
      }, 500);
    });
  });

</script>
</body>
</html>
